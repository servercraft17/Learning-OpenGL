#include <iostream>

#include <SDL3/SDL.h>

#include <GL/glew.h>

#include <SDL3/SDL_opengl.h>
#include <GL/glut.h>

#include <shaders.h>

#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600


void HandleEvent(SDL_Event& event);
void Update();
void Render();

// Vars
static SDL_Window* window;
static bool should_quit = false;


int main() {
// 1. Initialization
    if (!SDL_Init(SDL_INIT_VIDEO)) {
        SDL_Log("SDL Failed to initialize: %s", SDL_GetError());
        return 1;
    }

    window = SDL_CreateWindow("Learning OpenGL: Basic Triangle", WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_OPENGL);
    if (!window) {
        SDL_Log("SDL Failed to create a window: %s", SDL_GetError());
        return 1;
    }

    SDL_GL_SetAttribute( SDL_GL_CONTEXT_MAJOR_VERSION, 3 );
    SDL_GL_SetAttribute( SDL_GL_CONTEXT_MINOR_VERSION, 1 );
    SDL_GL_SetAttribute( SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);

    SDL_GLContext glContext = SDL_GL_CreateContext(window);
    if(!glContext) {
        SDL_Log("SDL Failed to create an OpenGL context: %s", SDL_GetError());
        return 1;
    }

    if (!SDL_GL_MakeCurrent(window, glContext)) {
        SDL_Log("ERROR: Failed to set the current OpenGL context: %s", SDL_GetError());
        return 1;
    }

    glewExperimental = GL_TRUE;
    GLenum glewError = glewInit();
    if (glewError != GLEW_OK) {
        SDL_Log("ERROR: Failed to initialize GLEW. %s", glewGetErrorString(glewError));
        return 1;
    }

    // Tell OpenGL the size of our window.
    glViewport(0,0,WINDOW_WIDTH, WINDOW_HEIGHT);

    // Set Vsync
    if (!SDL_GL_SetSwapInterval(0)) 
        SDL_Log("WARNING: Failed to set vsync. %s", SDL_GetError());

    // Some vertices of a triangle
    float vertices[] = {
        -0.5f, -0.5f, 0.0f,
         0.5f, -0.5f, 0.0f,
         0.0f,  0.5f, 0.0f
    };  

    // A VBO is just a buffer that can store a large amount of vertex data on GPU memory.

    // We create a VBO to store our vertex data in.
    unsigned VBO;
    glGenBuffers(1, &VBO);
    /*
        Binding a buffer is how we reference these buffers, so we don't have to pass the VBO, etc.. every time we 
            want to use it, instead we pass the target that we bound it too, in this case we bound our VBO to the GL_ARRAY_BUFFER 
            target.
        GL_ARRAY_BUFFER is the target used for accessing VBOs.
        We can bind multiple buffers at the same time as long as they are all bound to different targets.
        Saying this makes it sound like we can just bind any buffer object to any target, making it possible to bind two VBOs
            at the same time to access the vertices of both at the same time, but this is not the case. The target a buffer
            object is bound to tells OpenGL how to read that data, so binding a VBO to a target ment for handling texture data
            will cause alot of issue because OpenGL is reading your vertex data as if it was texture data.
    */
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    /*
        From now on any buffer calls made on the GL_ARRAY_BUFFER target will reference our VBO, until we either unbind our VBO
            from the GL_ARRAY_BUFFER target or we bind another VBO to the GL_ARRAY_BUFFER target.
        Now that we can access our VBO, we can put our vertex data into the buffer's memory.
        The GL_STATIC_DRAW just tells OpenGL how much the data in this buffer is used and changed, heres the 3 different options.
            - GL_STREAM_DRAW: data never changes and is not used often. (OpenGL will stream the data from DRAM to the GPU).
            - GL_STATIC_DRAW: data never changes and is used often. (OpenGL will store the data in VRAM, but in places that ensure faster reads.)
            - GL_DYNAMIC_DRAW: data changes often and is used often. (OpenGL will store the data in VRAM, but in places that ensure faster writes.)
        In this case, GL_STATIC_DRAW is the best option because we are going to be accessing this data every frame and not changing it.
    */
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    /*
        Now we want to make shaders that actually process this data we've sent to the GPU.
        OpenGL shaders are written in GLSL (Open[GL] [S]hading [L]anguage)
        Look in the shaders directory for info on writting shaders.
        Note that the extensions don't matter, because GLSL files dont actually exist, I just have it so that the contents of all the
            GLSL files are thrown into to a header file as string constants, because OpenGL doesn't load shaders from files, it loads
            and compiles the shaders from strings that you provide that contain all of the shader code.
    */
    /*
        After we write our shaders we want to actually use them, so we need to compile them.
        First we need to get the shader, like I said before, I have a header file that is auto-generated by the build system that puts all of our
            shaders into one header file, thats the '#include <shaders.h>' at the top.
        Just like how glGenBuffers gave us an ID that lets us bind the VBO to a target, glCreateShader gives us an ID to reference the shader by.
        Once we have created our shader we need to give it the shader's source code, which we use glShaderSource for. The second parameter of
            glShaderSource is just the number of strings you're passing to it, that can be left as 1, and the 4th parameter can be set to NULL.
    */
    unsigned vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &Shaders::vertex_basic_triangle, NULL);
    /*
        Then finally we can compile our shader, with a simple call to glCompileShader.
    */
    glCompileShader(vertexShader);

    // Check if compilation failed.
    int compilation_success;
    char compilation_log[1024];
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &compilation_success);
    if (!compilation_success) {
        // Second param is just the size of your char array.
        // And third param you can just leave NULL.
        glGetShaderInfoLog(vertexShader, 1024, NULL, compilation_log);
        SDL_Log("ERROR: Failed to compile vertex shader. %s", compilation_log);
    }



// 2. Game Loop
    while (!should_quit) {
        SDL_Event event;
        while (SDL_PollEvent(&event)) HandleEvent(event);
        Update();
        Render();
    }

// 3. Cleanup
    SDL_GL_DestroyContext(glContext);
    SDL_DestroyWindow(window);
    SDL_Quit();
}

void HandleEvent(SDL_Event &event) {
    if (event.type == SDL_EVENT_QUIT || (event.type == SDL_EVENT_KEY_DOWN && event.key.key == SDLK_ESCAPE)) {
        SDL_Log("Exiting...");
        should_quit=true;
        return;
    }
}

void Update() {

}

void Render() {
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
    
    // Swaps the frame buffer, essentially like SDL_RenderPresent() but for OpenGL
    SDL_GL_SwapWindow(window);
}
